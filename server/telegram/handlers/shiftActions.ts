/* eslint-env node */
import { Context } from 'telegraf';
import type { InlineKeyboardButton } from 'telegraf/types';
import { SessionData } from '../types.js';
import { repositories } from '../../repositories/index.js';
import { invalidateCompanyStatsByShift } from '../../lib/utils/cache.js';
import { logger } from '../../lib/logger.js';

type InlineKeyboard = InlineKeyboardButton[][];

export async function handleShiftActions(ctx: Context & { session: SessionData }) {
  const action = (ctx as any)?.callbackQuery?.data as string | undefined;
  const employeeId = ctx.session.employeeId;
  
  if (!action || !employeeId) {
    return ctx.answerCbQuery('‚ùå –û—à–∏–±–∫–∞: –¥–∞–Ω–Ω—ã–µ —Å–µ—Å—Å–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã');
  }

  try {
    // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é —Å–º–µ–Ω—É
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const shifts = await repositories.shift.findByEmployeeId(employeeId);
    const todayShift = shifts.find(s => {
      const shiftDate = new Date(s.planned_start_at);
      shiftDate.setHours(0, 0, 0, 0);
      return shiftDate.getTime() === today.getTime();
    });

    let message = '';
    let success = false;
    let shiftIdForMenu = todayShift?.id;

    switch (action) {
      case 'start_shift':
        // –ï—Å–ª–∏ —Å–º–µ–Ω—ã –Ω–µ—Ç, —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—É—é
        if (!todayShift) {
          const employee = await repositories.employee.findById(employeeId);
          if (!employee) {
            return ctx.answerCbQuery('‚ùå –°–æ—Ç—Ä—É–¥–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω');
          }

          const now = new Date();
          const endOfDay = new Date(now);
          endOfDay.setHours(23, 59, 59, 999);

          const newShift = await repositories.shift.create({
            employee_id: employeeId,
            planned_start_at: now,
            planned_end_at: endOfDay,
            status: 'active',
            actual_start_at: now
          });

          await repositories.shift.createWorkInterval({
            shift_id: newShift.id,
            start_at: now,
            source: 'bot'
          });

          // Invalidate company stats cache
          await invalidateCompanyStatsByShift({ employee_id: employeeId });

          message = '‚úÖ –°–º–µ–Ω–∞ –Ω–∞—á–∞—Ç–∞! –£–¥–∞—á–Ω–æ–π —Ä–∞–±–æ—Ç—ã!';
          success = true;
          shiftIdForMenu = newShift.id;
        } else if (todayShift.status === 'planned') {
          await repositories.shift.update(todayShift.id, {
            status: 'active',
            actual_start_at: new Date()
          });

          await repositories.shift.createWorkInterval({
            shift_id: todayShift.id,
            start_at: new Date(),
            source: 'bot'
          });

          // Invalidate company stats cache
          const employee = await repositories.employee.findById(employeeId);
          if (employee) {
            await invalidateCompanyStatsByShift({ employee_id: employee.id });
          }

          message = '‚úÖ –°–º–µ–Ω–∞ –Ω–∞—á–∞—Ç–∞! –£–¥–∞—á–Ω–æ–π —Ä–∞–±–æ—Ç—ã!';
          success = true;
        } else {
          message = '‚ùå –°–º–µ–Ω–∞ —É–∂–µ –Ω–∞—á–∞—Ç–∞ –∏–ª–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∞';
        }
        break;

      case 'start_break':
        if (!todayShift) {
          message = '‚ùå –°–º–µ–Ω–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞';
        } else if (todayShift.status === 'active') {
          // –ó–∞–≤–µ—Ä—à–∞–µ–º —Ç–µ–∫—É—â–∏–π —Ä–∞–±–æ—á–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
          const workIntervals = await repositories.shift.findWorkIntervalsByShiftId(todayShift.id);
          const activeWork = workIntervals.find(wi => !wi.end_at);
          
          if (activeWork) {
            await repositories.shift.updateWorkInterval(activeWork.id, {
              end_at: new Date()
            });
          }

          // –°–æ–∑–¥–∞–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª –ø–µ—Ä–µ—Ä—ã–≤–∞
          await repositories.shift.createBreakInterval({
            shift_id: todayShift.id,
            start_at: new Date(),
            type: 'lunch',
            source: 'bot'
          });

          message = 'üçΩ –ü–µ—Ä–µ—Ä—ã–≤ –Ω–∞—á–∞—Ç! –ü—Ä–∏—è—Ç–Ω–æ–≥–æ –æ—Ç–¥—ã—Ö–∞!';
          success = true;
        } else {
          message = '‚ùå –°–º–µ–Ω–∞ –Ω–µ –∞–∫—Ç–∏–≤–Ω–∞';
        }
        break;

      case 'end_break':
        if (!todayShift) {
          message = '‚ùå –°–º–µ–Ω–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞';
        } else {
          // –ó–∞–≤–µ—Ä—à–∞–µ–º –ø–µ—Ä–µ—Ä—ã–≤
          const breakIntervals = await repositories.shift.findBreakIntervalsByShiftId(todayShift.id);
        const activeBreak = breakIntervals.find(bi => !bi.end_at);
        
        if (activeBreak) {
          await repositories.shift.updateBreakInterval(activeBreak.id, {
            end_at: new Date()
          });

          // –ù–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—ã–π —Ä–∞–±–æ—á–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
          await repositories.shift.createWorkInterval({
            shift_id: todayShift.id,
            start_at: new Date(),
            source: 'bot'
          });

          message = '‚òëÔ∏è –ü–µ—Ä–µ—Ä—ã–≤ –∑–∞–≤–µ—Ä—à—ë–Ω! –° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º –∫ —Ä–∞–±–æ—Ç–µ!';
          success = true;
        } else {
          message = '‚ùå –ê–∫—Ç–∏–≤–Ω—ã–π –ø–µ—Ä–µ—Ä—ã–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω';
        }
        }
        break;

      case 'end_shift':
        if (!todayShift) {
          message = '‚ùå –°–º–µ–Ω–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞';
        } else if (todayShift.status === 'active') {
          // –ó–∞–≤–µ—Ä—à–∞–µ–º —Ç–µ–∫—É—â–∏–π —Ä–∞–±–æ—á–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
          const workIntervals = await repositories.shift.findWorkIntervalsByShiftId(todayShift.id);
          const activeWork = workIntervals.find(wi => !wi.end_at);
          
          if (activeWork) {
            await repositories.shift.updateWorkInterval(activeWork.id, {
              end_at: new Date()
            });
          }

          // –ó–∞–≤–µ—Ä—à–∞–µ–º —Å–º–µ–Ω—É
          await repositories.shift.update(todayShift.id, {
            status: 'completed',
            actual_end_at: new Date()
          });

          // Invalidate company stats cache
          if (employeeId) {
            await invalidateCompanyStatsByShift({ employee_id: employeeId });
          }

          message = 'üïî –°–º–µ–Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –°–ø–∞—Å–∏–±–æ –∑–∞ —Ä–∞–±–æ—Ç—É!';
          success = true;

          // –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –æ—Ç—á—ë—Ç
          ctx.session.waitingForReport = todayShift.id;
          void setTimeout(() => {
            void ctx.reply(`
üìù *–û—Ç—á—ë—Ç –æ —Å–º–µ–Ω–µ*

–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ä–∞—Å—Å–∫–∞–∂–∏—Ç–µ, —á—Ç–æ –≤—ã —Å–¥–µ–ª–∞–ª–∏ —Å–µ–≥–æ–¥–Ω—è:

‚Ä¢ –ö–∞–∫–∏–µ –∑–∞–¥–∞—á–∏ –≤—ã–ø–æ–ª–Ω–∏–ª–∏?
‚Ä¢ –ë—ã–ª–∏ –ª–∏ –ø—Ä–æ–±–ª–µ–º—ã –∏–ª–∏ –∑–∞–¥–µ—Ä–∂–∫–∏?
‚Ä¢ –ß—Ç–æ –ø–ª–∞–Ω–∏—Ä—É–µ—Ç–µ –Ω–∞ –∑–∞–≤—Ç—Ä–∞?

–ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –æ—Ç—á—ë—Ç–æ–º.
            `, { parse_mode: 'Markdown' });
          }, 2000);
        } else {
          message = '‚ùå –°–º–µ–Ω–∞ –Ω–µ –∞–∫—Ç–∏–≤–Ω–∞';
        }
        break;

      default:
        message = '‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ';
    }

    await ctx.answerCbQuery(message);
    
    if (success && shiftIdForMenu) {
      // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ–Ω—é
      void setTimeout(() => {
        void showUpdatedMenu(ctx, shiftIdForMenu);
      }, 1000);
    }

  } catch (error) {
    logger.error('Error in shift action', error);
    await ctx.answerCbQuery('‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –¥–µ–π—Å—Ç–≤–∏—è');
  }
}

async function showUpdatedMenu(ctx: Context & { session: SessionData }, shiftId: string) {
  try {
    const shift = await repositories.shift.findById(shiftId);
    if (!shift) {
      // –ï—Å–ª–∏ —Å–º–µ–Ω–∞ –±—ã–ª–∞ —É–¥–∞–ª–µ–Ω–∞, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –¥–ª—è –Ω–∞—á–∞–ª–∞ –Ω–æ–≤–æ–π
      const keyboard: InlineKeyboard = [
        [
          { text: '‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å —Å–º–µ–Ω—É', callback_data: 'start_shift' }
        ]
      ];
      return ctx.reply(`
üìä *–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–º–µ–Ω–æ–π*

üìÖ –°–º–µ–Ω–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –í—ã –º–æ–∂–µ—Ç–µ –Ω–∞—á–∞—Ç—å –Ω–æ–≤—É—é —Å–º–µ–Ω—É.

–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:
      `, {
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: keyboard
        }
      });
    }

    const workIntervals = await repositories.shift.findWorkIntervalsByShiftId(shiftId);
    const breakIntervals = await repositories.shift.findBreakIntervalsByShiftId(shiftId);
    
    const activeWork = workIntervals.find(wi => !wi.end_at);
    const activeBreak = breakIntervals.find(bi => !bi.end_at);

    let status = 'üìÖ –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∞';
    if (shift.status === 'active') {
      status = activeBreak ? 'üçΩ –ü–µ—Ä–µ—Ä—ã–≤' : 'üíº –†–∞–±–æ—Ç–∞—é';
    } else if (shift.status === 'completed') {
      status = '‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–∞';
    }

    let keyboard: InlineKeyboard = [];

    if (shift.status === 'planned') {
      keyboard = [
        [
          { text: '‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å —Å–º–µ–Ω—É', callback_data: 'start_shift' }
        ]
      ];
    } else if (shift.status === 'active') {
      if (activeBreak) {
        keyboard = [
          [{ text: '‚òëÔ∏è –í–µ—Ä–Ω—É–ª—Å—è', callback_data: 'end_break' }]
        ];
      } else {
        keyboard = [
          [
            { text: 'üçΩ –ù–∞—á–∞—Ç—å –ø–µ—Ä–µ—Ä—ã–≤', callback_data: 'start_break' },
            { text: 'üïî –ó–∞–≤–µ—Ä—à–∏—Ç—å —Å–º–µ–Ω—É', callback_data: 'end_shift' }
          ]
        ];
      }
    }

    const message = `
üìä *–°—Ç–∞—Ç—É—Å —Å–º–µ–Ω—ã: ${status}*

‚è∞ *–í—Ä–µ–º—è:* ${new Date(shift.planned_start_at).toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' })} - ${new Date(shift.planned_end_at).toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' })}

${activeWork ? `‚è± *–ù–∞—á–∞–ª —Ä–∞–±–æ—Ç—É:* ${new Date(activeWork.start_at).toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' })}` : ''}
${activeBreak ? `üçΩ *–ü–µ—Ä–µ—Ä—ã–≤ —Å:* ${new Date(activeBreak.start_at).toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' })}` : ''}
    `;

    if (keyboard.length > 0) {
      void ctx.reply(message, {
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: keyboard
        }
      });
    } else {
      void ctx.reply(message, { parse_mode: 'Markdown' });
    }

  } catch (error) {
    logger.error('Error showing updated menu', error);
  }
}
